{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"software architecture"},{"location":"/index.html#software-architecture","text":"What’s issues for software development?","title":"software architecture"},{"location":"/sub/issues.html","text":"","title":"Whats issues for software development?"},{"location":"/sub/issues.html#whats-issues-for-software-development-","text":"","title":"What’s issues for software development?"},{"location":"/sub/issues.html#","text":"Code for authentication:\nFor application authentication, there are 3 types: by application, by SAML at first stage, and add by Oauth in later version. For authorization, there is not needed any change for different change.\nCode for frontend controller lazy val secureSource = config.getOptional[Boolean](\"useidam\") match {\n   case Some(true) => config.getOptional[Boolean](\"pwcoauth.useoauth\") match {\n     case Some(true) => index3\n     case _ => index2\n   }\n   case _ => index\n }\n\n def index2: Action[AnyContent] = {\n   secureAction(\n     assets.at(\"index.html\")\n   )\n }\n\n def index3: Action[AnyContent] = {\n   secureActionOauth(\n     assets.at(\"index.html\")\n   )\n }\n\n def index: Action[AnyContent] = assets.at(\"index.html\") Saml def secureAction[A](action: Action[A]): Action[A] = Secure(\"SAML2Client\").async(action.parser) { implicit request =>\n  ...\n  val userInfoMap = Map(\"email\"->profiles.head.getAttribute(emailAttrStr).toString.stripPrefix(\"[\").stripSuffix(\"]\"))\n  ...\n  userTimeOpt match {\n    case Some(userTime) if nowTime - userTime.toInt > maxTimeout =>\n      Future( Redirect(\"/\").flashing(\"success\" -> \"Session timeout, you need to login.\")\n        .discardingCookies(DiscardingCookie(\"PLAY_SESSION\")).withNewSession.withHeaders(\"Cache-Control\"-> \"no-cache\"))\n    case _=>    action(request).map {\n      result =>\n        result.withSession(request.session.+(\"email\"->userInfoMap(\"email\"))\n          .+(\"useidm\"->\"true\")\n          .+(\"userTime\"->nowTime.toString)\n          .+(\"privilege\" -> privilege)).withHeaders(\"Cache-Control\"-> \"no-cache\")\n    }\n  }\n} Oauth def secureActionOauth[A](action: Action[A]): Action[A] = Secure(\"PwCClient\").async(action.parser) { implicit request =>\n  ...\n  val userInfoMap = Map(\"email\"->profiles.head.getAuthenticationAttribute(\"email\").toString)\n  updateUserLastActiveTime(userInfoMap.get(\"email\"))\n  ...\n  userTimeOpt match {\n    case Some(userTime) if nowTime - userTime.toInt > maxTimeout =>\n      Future( Redirect(\"/\").flashing(\"success\" -> \"Session timeout, you need to login.\")\n        .discardingCookies(DiscardingCookie(\"PLAY_SESSION\")).withNewSession.withHeaders(\"Cache-Control\"-> \"no-cache\"))\n    case _=>    action(request).map {\n      result =>\n        result.withSession(request.session.+(\"email\"->userInfoMap(\"email\"))\n          .+(\"useidm\"->\"true\")\n          .+(\"userTime\"->nowTime.toString)\n          .+(\"privilege\" -> privilege)).withHeaders(\"Cache-Control\"-> \"no-cache\")\n          .bakeCookies()\n    }\n  }\n} Authentication def createEngageuser() =\n  deadbolt.Pattern(value = \"(v_admin)|(v_lead)\", patternType = PatternType.REGEX)(trim(parse.json)) {implicit authRequest =>\n    // Action.async(trim(parse.json)) { implicit authRequest =>\n    try {\n        ...\n    } catch {\n      case ValidationException(msg) => Future(BadRequest(msg))\n    }\n  }","title":"Big ball of mud"}]}